# -*- coding: utf-8 -*-
"""
modbus_code_generator.py
Enhanced Generate C/H files for Modbus RTU Configuration with Operation/Mode support
"""

import re


class ModbusCodeGenerator:
    def __init__(self, config):
        self.config = config
    
    def generate_files(self, output_dir):
        """Generate enhanced .h and .c files"""
        all_registers = self._get_all_registers()
        optimized_ranges = self._get_optimized_ranges(all_registers)
        
        header_content = self._generate_header(optimized_ranges, all_registers)
        with open(f'{output_dir}/modbus_registers.h', 'w', encoding='utf-8') as f:
            f.write(header_content)
        
        source_content = self._generate_source(optimized_ranges, all_registers)
        with open(f'{output_dir}/modbus_registers.c', 'w', encoding='utf-8') as f:
            f.write(source_content)
    
    def _get_all_registers(self):
        """Get all registers from config"""
        all_registers = []
        
        if self.config['is_master']:
            if 'slave_registers' in self.config:
                for slave_id, registers in self.config['slave_registers'].items():
                    for reg in registers:
                        reg_with_slave = reg.copy()
                        reg_with_slave['slave_id'] = slave_id
                        all_registers.append(reg_with_slave)
        else:
            all_registers = self.config['registers']
        
        return all_registers
    
    def _get_optimized_ranges(self, registers):
        """Calculate optimized register ranges"""
        if not registers:
            return []
        
        type_groups = {}
        for reg in registers:
            modbus_type = reg.get('modbus_type', [0, 1, 3, 4][reg['type']])
            
            if modbus_type not in type_groups:
                type_groups[modbus_type] = []
            type_groups[modbus_type].append(reg['internal_address'])
        
        optimized_ranges = []
        for modbus_type, addresses in type_groups.items():
            addresses.sort()
            ranges = self._create_ranges(addresses, modbus_type)
            optimized_ranges.extend(ranges)
        
        return optimized_ranges
    
    def _create_ranges(self, addresses, reg_type):
        """Create register ranges from addresses"""
        if not addresses:
            return []
        
        ranges = []
        start = addresses[0]
        count = 1
        
        for i in range(1, len(addresses)):
            if addresses[i] == addresses[i-1] + 1:
                count += 1
            else:
                ranges.append({'start': start, 'count': count, 'type': reg_type})
                start = addresses[i]
                count = 1
        
        ranges.append({'start': start, 'count': count, 'type': reg_type})
        
        return ranges
    
    def _generate_header(self, optimized_ranges, all_registers):
        """Generate enhanced .h file content"""
        reg_by_type = {0: [], 1: [], 3: [], 4: []}
        for reg in all_registers:
            modbus_type = reg.get('modbus_type', [0, 1, 3, 4][reg['type']])
            reg_by_type[modbus_type].append(reg)
        
        coil_count = len(reg_by_type[0])
        di_count = len(reg_by_type[1])
        ir_count = len(reg_by_type[3])
        hr_count = len(reg_by_type[4])
        
        header = '''/**
 * \\file            modbus_registers.h
 * \\brief           Enhanced Modbus register mapping definitions with Operation/Mode support
 */

/*
 * Copyright (c) 2025 Pham Nam Hien
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without restriction,
 * including without limitation the rights to use, copy, modify, merge,
 * publish, distribute, sublicense, and/or sell copies of the Software,
 * and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE
 * AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 *
 * This file is part of Enhanced Modbus RTU library v2.0.
 *
 * Author:          Generated by Enhanced Modbus Configuration Tool v2.0
 */
#ifndef MODBUS_REGISTERS_H
#define MODBUS_REGISTERS_H

#include <stdint.h>

#ifdef __cplusplus
extern "C" {
#endif /* __cplusplus */

/**
 * \\brief           Enable enhanced register mapping mode with Operation/Mode support
 */
#define MODBUS_USE_ENHANCED_REGISTER_MAPPING        (1)

/* Configuration settings - Variables (can be modified at runtime) */
'''
        
        settings = self.config.get('settings', {})
        
        # Generate extern declarations for variables instead of #defines
        header += "\n/* External variable declarations for configuration */\n"
        for setting in settings.get('common', []):
            var_name = setting['var_name'].lower()
            header += f"extern uint32_t {var_name};\n"
        
        if self.config['is_master']:
            header += "\n/* Device type */\n"
            header += "#define MODBUS_DEVICE_TYPE_MASTER                   (1)\n"
            if self.config.get('target_slaves'):
                header += f"/* Target slave IDs: {', '.join(map(str, self.config['target_slaves']))} */\n"
            header += "\n/* Enhanced Master-specific configuration variables */\n"
            for setting in settings.get('master', []):
                var_name = setting['var_name'].lower()
                header += f"extern uint32_t {var_name};\n"
        else:
            header += "\n/* Device type */\n"
            header += "#define MODBUS_DEVICE_TYPE_SLAVE                    (1)\n"
            header += "\n/* Slave-specific configuration variables */\n"
            for setting in settings.get('slave', []):
                var_name = setting['var_name'].lower()
                header += f"extern uint32_t {var_name};\n"
        
        header += f"\n/* Register counts (optimized memory) */\n"
        header += f"#define MODBUS_COIL_COUNT                           ({coil_count})\n"
        header += f"#define MODBUS_DISCRETE_INPUT_COUNT                 ({di_count})\n"
        header += f"#define MODBUS_INPUT_REGISTER_COUNT                 ({ir_count})\n"
        header += f"#define MODBUS_HOLDING_REGISTER_COUNT               ({hr_count})\n"
        
        header += "\n/* Register internal address definitions */\n"
        
        for modbus_type in [4, 3, 0, 1]:
            if not reg_by_type[modbus_type]:
                continue
            
            type_names = {0: 'Coil', 1: 'Discrete Input', 3: 'Input Register', 4: 'Holding Register'}
            header += f"\n/* {type_names[modbus_type]} internal addresses */\n"
            
            for reg in sorted(reg_by_type[modbus_type], key=lambda x: x['internal_address']):
                if self.config['is_master'] and 'slave_id' in reg:
                    # For master mode: include slave ID in define name to avoid conflicts
                    base_tag = reg.get('tag_name', f'REG_{reg["internal_address"]}')
                    # Remove any existing slave prefix if present
                    if base_tag.startswith(('S1_', 'S2_', 'S3_', 'S4_', 'S5_', 'S6_', 'S7_', 'S8_', 'S9_')):
                        base_tag = base_tag[3:]  # Remove "SX_" prefix
                    tag_name = f'S{reg["slave_id"]}_{base_tag}'
                    comment = f'/* Slave {reg["slave_id"]}, Addr {reg["internal_address"]}, Op: {reg.get("operation", "N/A")}, Mode: {reg.get("mode", "N/A")} */'
                else:
                    # For slave mode: use original tag name
                    tag_name = reg.get('tag_name', f'REG_{reg["internal_address"]}')
                    comment = f'/* Internal addr {reg["internal_address"]} */'
                
                header += f"#define {tag_name}_ADDR{' ' * max(1, 35 - len(tag_name))} ({reg['internal_address']:<5})  {comment}\n"
        
        header += f"\n/* Register mapping indices */\n"
        header += "/* Use these indices to access g_modbus_xxx_registers[] arrays */\n"
        
        for modbus_type in [4, 3, 0, 1]:
            if not reg_by_type[modbus_type]:
                continue
            
            sorted_regs = sorted(reg_by_type[modbus_type], key=lambda x: x['internal_address'])
            for idx, reg in enumerate(sorted_regs):
                if self.config['is_master'] and 'slave_id' in reg:
                    # For master mode: include slave ID in define name to avoid conflicts
                    base_tag = reg.get('tag_name', f'REG_{reg["internal_address"]}')
                    # Remove any existing slave prefix if present
                    if base_tag.startswith(('S1_', 'S2_', 'S3_', 'S4_', 'S5_', 'S6_', 'S7_', 'S8_', 'S9_')):
                        base_tag = base_tag[3:]  # Remove "SX_" prefix
                    tag_name = f'S{reg["slave_id"]}_{base_tag}'
                else:
                    # For slave mode: use original tag name
                    tag_name = reg.get('tag_name', f'REG_{reg["internal_address"]}')
                
                header += f"#define {tag_name}_IDX{' ' * max(1, 36 - len(tag_name))} ({idx})\n"
        
        header += "\n/* Direct access macros - use these for easy register access */\n"
        header += "/* Example: TEMPERATURE = 34; instead of g_modbus_holding_registers[TEMPERATURE_IDX] = 34; */\n\n"
        
        if reg_by_type[4]:
            header += "/* Holding Register access macros */\n"
            sorted_regs = sorted(reg_by_type[4], key=lambda x: x['internal_address'])
            for idx, reg in enumerate(sorted_regs):
                if self.config['is_master'] and 'slave_id' in reg:
                    # For master mode: include slave ID in define name
                    base_tag = reg.get('tag_name', f'REG_{reg["internal_address"]}')
                    if base_tag.startswith(('S1_', 'S2_', 'S3_', 'S4_', 'S5_', 'S6_', 'S7_', 'S8_', 'S9_')):
                        base_tag = base_tag[3:]
                    tag_name = f'S{reg["slave_id"]}_{base_tag}'
                else:
                    tag_name = reg.get('tag_name', f'REG_{reg["internal_address"]}')
                header += f"#define {tag_name:<40} g_modbus_holding_registers[{tag_name}_IDX]\n"
        
        if reg_by_type[3]:
            header += "\n/* Input Register access macros */\n"
            sorted_regs = sorted(reg_by_type[3], key=lambda x: x['internal_address'])
            for idx, reg in enumerate(sorted_regs):
                if self.config['is_master'] and 'slave_id' in reg:
                    # For master mode: include slave ID in define name
                    base_tag = reg.get('tag_name', f'REG_{reg["internal_address"]}')
                    if base_tag.startswith(('S1_', 'S2_', 'S3_', 'S4_', 'S5_', 'S6_', 'S7_', 'S8_', 'S9_')):
                        base_tag = base_tag[3:]
                    tag_name = f'S{reg["slave_id"]}_{base_tag}'
                else:
                    tag_name = reg.get('tag_name', f'REG_{reg["internal_address"]}')
                header += f"#define {tag_name:<40} g_modbus_input_registers[{tag_name}_IDX]\n"
        
        if reg_by_type[0]:
            header += "\n/* Coil access macros (bit access) */\n"
            sorted_regs = sorted(reg_by_type[0], key=lambda x: x['internal_address'])
            for idx, reg in enumerate(sorted_regs):
                if self.config['is_master'] and 'slave_id' in reg:
                    # For master mode: include slave ID in define name
                    base_tag = reg.get('tag_name', f'REG_{reg["internal_address"]}')
                    if base_tag.startswith(('S1_', 'S2_', 'S3_', 'S4_', 'S5_', 'S6_', 'S7_', 'S8_', 'S9_')):
                        base_tag = base_tag[3:]
                    tag_name = f'S{reg["slave_id"]}_{base_tag}'
                else:
                    tag_name = reg.get('tag_name', f'REG_{reg["internal_address"]}')
                byte_idx = idx // 8
                bit_idx = idx % 8
                header += f"#define {tag_name}_SET(){' ' * max(1, 32 - len(tag_name))} (g_modbus_coils[{byte_idx}] |= (1 << {bit_idx}))\n"
                header += f"#define {tag_name}_CLR(){' ' * max(1, 32 - len(tag_name))} (g_modbus_coils[{byte_idx}] &= ~(1 << {bit_idx}))\n"
                header += f"#define {tag_name}_READ(){' ' * max(1, 31 - len(tag_name))} ((g_modbus_coils[{byte_idx}] >> {bit_idx}) & 1)\n"
        
        if reg_by_type[1]:
            header += "\n/* Discrete Input access macros (bit access) */\n"
            sorted_regs = sorted(reg_by_type[1], key=lambda x: x['internal_address'])
            for idx, reg in enumerate(sorted_regs):
                if self.config['is_master'] and 'slave_id' in reg:
                    # For master mode: include slave ID in define name
                    base_tag = reg.get('tag_name', f'REG_{reg["internal_address"]}')
                    if base_tag.startswith(('S1_', 'S2_', 'S3_', 'S4_', 'S5_', 'S6_', 'S7_', 'S8_', 'S9_')):
                        base_tag = base_tag[3:]
                    tag_name = f'S{reg["slave_id"]}_{base_tag}'
                else:
                    tag_name = reg.get('tag_name', f'REG_{reg["internal_address"]}')
                byte_idx = idx // 8
                bit_idx = idx % 8
                header += f"#define {tag_name}_SET(){' ' * max(1, 32 - len(tag_name))} (g_modbus_discrete_inputs[{byte_idx}] |= (1 << {bit_idx}))\n"
                header += f"#define {tag_name}_CLR(){' ' * max(1, 32 - len(tag_name))} (g_modbus_discrete_inputs[{byte_idx}] &= ~(1 << {bit_idx}))\n"
                header += f"#define {tag_name}_READ(){' ' * max(1, 31 - len(tag_name))} ((g_modbus_discrete_inputs[{byte_idx}] >> {bit_idx}) & 1)\n"
        
        # Add operation/mode information for Master mode
        if self.config['is_master']:
            header += f"\n/* Master Mode: Operation and Mode Information */\n"
            
            # Group by operation type
            read_regs = []
            write_once_regs = []
            write_cyclic_regs = []
            
            for reg in all_registers:
                operation = reg.get('operation', 'Read')
                mode = reg.get('mode', 'N/A')
                
                if operation == 'Read':
                    read_regs.append(reg)
                elif operation == 'Write' and mode == 'One-time':
                    write_once_regs.append(reg)
                elif operation == 'Write' and mode == 'Cyclic':
                    write_cyclic_regs.append(reg)
            
            header += f"#define MODBUS_READ_REGISTERS_COUNT                 ({len(read_regs)})\n"
            header += f"#define MODBUS_WRITE_ONCE_REGISTERS_COUNT           ({len(write_once_regs)})\n"
            header += f"#define MODBUS_WRITE_CYCLIC_REGISTERS_COUNT         ({len(write_cyclic_regs)})\n"
        
        header += f"\n/* Register ranges configuration */\n"
        header += f"#define MODBUS_REGISTER_RANGES_COUNT                ({len(optimized_ranges)})\n\n"
        
        header += '''/**
 * \\brief           Enhanced register range structure
 */
typedef struct {
    uint16_t start_addr;                            /* Starting internal address */
    uint16_t count;                                 /* Number of consecutive registers */
    uint8_t  reg_type;                              /* Register type (0=coil, 1=DI, 3=IR, 4=HR) */
} modbus_register_range_t;

/**
 * \\brief           Enhanced register mapping structure with operation/mode support
 */
typedef struct {
    uint16_t internal_addr;                         /* Internal address (for Modbus protocol) */
    uint16_t array_index;                           /* Index in data array */
    uint8_t  operation;                             /* 0=Read, 1=Write (Master mode only) */
    uint8_t  mode;                                  /* 0=One-time, 1=Cyclic (Write operations only) */
} modbus_register_map_enhanced_t;

/* External variable declarations */
extern const modbus_register_range_t g_modbus_register_ranges[];
extern const modbus_register_map_enhanced_t g_modbus_holding_register_map[];
extern const modbus_register_map_enhanced_t g_modbus_input_register_map[];
extern const modbus_register_map_enhanced_t g_modbus_coil_map[];
extern const modbus_register_map_enhanced_t g_modbus_discrete_input_map[];

extern uint16_t g_modbus_holding_registers[];
extern uint16_t g_modbus_input_registers[];
extern uint8_t  g_modbus_coils[];
extern uint8_t  g_modbus_discrete_inputs[];

/* Function prototypes */
uint8_t     modbus_is_register_valid(uint16_t addr, uint8_t reg_type);
int32_t     modbus_get_register_ranges(const modbus_register_range_t** ranges);
void        modbus_registers_init(void);

/* Enhanced functions for Master mode */
#if defined(MODBUS_DEVICE_TYPE_MASTER)
uint8_t     modbus_is_read_register(uint16_t addr, uint8_t reg_type);
uint8_t     modbus_is_write_register(uint16_t addr, uint8_t reg_type);
uint8_t     modbus_is_cyclic_write_register(uint16_t addr, uint8_t reg_type);
int32_t     modbus_get_read_registers_count(void);
int32_t     modbus_get_write_registers_count(void);
#endif

#ifdef __cplusplus
}
#endif /* __cplusplus */

#endif /* MODBUS_REGISTERS_H */
'''
        
        return header
    
    def _generate_source(self, optimized_ranges, all_registers):
        """Generate enhanced .c file content"""
        reg_by_type = {0: [], 1: [], 3: [], 4: []}
        for reg in all_registers:
            modbus_type = reg.get('modbus_type', [0, 1, 3, 4][reg['type']])
            reg_by_type[modbus_type].append(reg)
        
        for t in reg_by_type:
            reg_by_type[t].sort(key=lambda x: x['internal_address'])
        
        source = '''/**
 * \\file            modbus_registers.c
 * \\brief           Enhanced Modbus register mapping implementation with Operation/Mode support
 */

/*
 * Copyright (c) 2025 Pham Nam Hien
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without restriction,
 * including without limitation the rights to use, copy, modify, merge,
 * publish, distribute, sublicense, and/or sell copies of the Software,
 * and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE
 * AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 *
 * This file is part of Enhanced Modbus RTU library v2.0.
 *
 * Author:          Generated by Enhanced Modbus Configuration Tool v2.0
 */
#include "modbus_registers.h"

/* Configuration variables - can be modified at runtime */
'''
        
        settings = self.config.get('settings', {})
        
        # Generate variable definitions instead of #defines
        source += "\n/* Common configuration variables */\n"
        for setting in settings.get('common', []):
            var_name = setting['var_name'].lower()
            value = setting['value']
            source += f"uint32_t {var_name} = {value};\n"
        
        if self.config['is_master']:
            source += "\n/* Enhanced Master-specific configuration variables */\n"
            for setting in settings.get('master', []):
                var_name = setting['var_name'].lower()
                value = setting['value']
                source += f"uint32_t {var_name} = {value};\n"
        else:
            source += "\n/* Slave-specific configuration variables */\n"
            for setting in settings.get('slave', []):
                var_name = setting['var_name'].lower()
                value = setting['value']
                source += f"uint32_t {var_name} = {value};\n"
        
        source += "\n/* Data arrays - only allocate what we actually use */\n"
        
        hr_count = len(reg_by_type[4])
        ir_count = len(reg_by_type[3])
        coil_count = len(reg_by_type[0])
        di_count = len(reg_by_type[1])
        
        if hr_count > 0:
            source += f"uint16_t g_modbus_holding_registers[{hr_count}];\n"
        else:
            source += f"uint16_t g_modbus_holding_registers[1];            /* Placeholder */\n"
        
        if ir_count > 0:
            source += f"uint16_t g_modbus_input_registers[{ir_count}];\n"
        else:
            source += f"uint16_t g_modbus_input_registers[1];              /* Placeholder */\n"
        
        if coil_count > 0:
            coil_bytes = (coil_count + 7) // 8
            source += f"uint8_t  g_modbus_coils[{coil_bytes}];\n"
        else:
            source += f"uint8_t  g_modbus_coils[1];                        /* Placeholder */\n"
        
        if di_count > 0:
            di_bytes = (di_count + 7) // 8
            source += f"uint8_t  g_modbus_discrete_inputs[{di_bytes}];\n"
        else:
            source += f"uint8_t  g_modbus_discrete_inputs[1];              /* Placeholder */\n"
        
        source += "\n/* Enhanced address to array index mapping with operation/mode info */\n"
        
        if hr_count > 0:
            source += f"const modbus_register_map_enhanced_t g_modbus_holding_register_map[{hr_count}] = {{\n"
            # Calculate max width for data part to align comments
            max_addr_width = max(len(str(reg['internal_address'])) for reg in reg_by_type[4])
            max_idx_width = max(len(str(idx)) for idx in range(hr_count))
            
            for idx, reg in enumerate(reg_by_type[4]):
                if self.config['is_master'] and 'slave_id' in reg:
                    # For master mode: include slave ID in comment
                    base_tag = reg.get('tag_name', f'REG_{reg["internal_address"]}')
                    if base_tag.startswith(('S1_', 'S2_', 'S3_', 'S4_', 'S5_', 'S6_', 'S7_', 'S8_', 'S9_')):
                        base_tag = base_tag[3:]
                    tag_name = f'S{reg["slave_id"]}_{base_tag}'
                else:
                    tag_name = reg.get('tag_name', f'REG_{reg["internal_address"]}')
                
                operation = 0 if reg.get('operation', 'Read') == 'Read' else 1
                mode = 0 if reg.get('mode', 'One-time') == 'One-time' else 1
                
                # Format with dynamic padding to align commas
                data_str = f"{{{reg['internal_address']}, {idx}, {operation}, {mode}}}"
                padding = max_addr_width + max_idx_width + 12  # Base padding for {}, spaces, commas
                source += f"    {data_str},{'':>{padding - len(data_str)}} /* {tag_name} - {reg.get('operation', 'N/A')}/{reg.get('mode', 'N/A')} */\n"
            source += "};\n\n"
        else:
            source += "const modbus_register_map_enhanced_t g_modbus_holding_register_map[1] = {{0, 0, 0, 0}};\n\n"
        
        if ir_count > 0:
            source += f"const modbus_register_map_enhanced_t g_modbus_input_register_map[{ir_count}] = {{\n"
            # Calculate max width for data part to align comments
            max_addr_width = max(len(str(reg['internal_address'])) for reg in reg_by_type[3])
            max_idx_width = max(len(str(idx)) for idx in range(ir_count))
            
            for idx, reg in enumerate(reg_by_type[3]):
                if self.config['is_master'] and 'slave_id' in reg:
                    # For master mode: include slave ID in comment
                    base_tag = reg.get('tag_name', f'REG_{reg["internal_address"]}')
                    if base_tag.startswith(('S1_', 'S2_', 'S3_', 'S4_', 'S5_', 'S6_', 'S7_', 'S8_', 'S9_')):
                        base_tag = base_tag[3:]
                    tag_name = f'S{reg["slave_id"]}_{base_tag}'
                else:
                    tag_name = reg.get('tag_name', f'REG_{reg["internal_address"]}')
                
                operation = 0 if reg.get('operation', 'Read') == 'Read' else 1
                mode = 0 if reg.get('mode', 'One-time') == 'One-time' else 1
                
                # Format with dynamic padding to align commas
                data_str = f"{{{reg['internal_address']}, {idx}, {operation}, {mode}}}"
                padding = max_addr_width + max_idx_width + 12  # Base padding for {}, spaces, commas
                source += f"    {data_str},{'':>{padding - len(data_str)}} /* {tag_name} - {reg.get('operation', 'N/A')}/{reg.get('mode', 'N/A')} */\n"
            source += "};\n\n"
        else:
            source += "const modbus_register_map_enhanced_t g_modbus_input_register_map[1] = {{0, 0, 0, 0}};\n\n"
        
        if coil_count > 0:
            source += f"const modbus_register_map_enhanced_t g_modbus_coil_map[{coil_count}] = {{\n"
            # Calculate max width for data part to align comments
            max_addr_width = max(len(str(reg['internal_address'])) for reg in reg_by_type[0])
            max_idx_width = max(len(str(idx)) for idx in range(coil_count))
            
            for idx, reg in enumerate(reg_by_type[0]):
                if self.config['is_master'] and 'slave_id' in reg:
                    # For master mode: include slave ID in comment
                    base_tag = reg.get('tag_name', f'REG_{reg["internal_address"]}')
                    if base_tag.startswith(('S1_', 'S2_', 'S3_', 'S4_', 'S5_', 'S6_', 'S7_', 'S8_', 'S9_')):
                        base_tag = base_tag[3:]
                    tag_name = f'S{reg["slave_id"]}_{base_tag}'
                else:
                    tag_name = reg.get('tag_name', f'REG_{reg["internal_address"]}')
                
                operation = 0 if reg.get('operation', 'Read') == 'Read' else 1
                mode = 0 if reg.get('mode', 'One-time') == 'One-time' else 1
                
                # Format with dynamic padding to align commas
                data_str = f"{{{reg['internal_address']}, {idx}, {operation}, {mode}}}"
                padding = max_addr_width + max_idx_width + 12  # Base padding for {}, spaces, commas
                source += f"    {data_str},{'':>{padding - len(data_str)}} /* {tag_name} - {reg.get('operation', 'N/A')}/{reg.get('mode', 'N/A')} */\n"
            source += "};\n\n"
        else:
            source += "const modbus_register_map_enhanced_t g_modbus_coil_map[1] = {{0, 0, 0, 0}};\n\n"
        
        if di_count > 0:
            source += f"const modbus_register_map_enhanced_t g_modbus_discrete_input_map[{di_count}] = {{\n"
            # Calculate max width for data part to align comments
            max_addr_width = max(len(str(reg['internal_address'])) for reg in reg_by_type[1])
            max_idx_width = max(len(str(idx)) for idx in range(di_count))
            
            for idx, reg in enumerate(reg_by_type[1]):
                if self.config['is_master'] and 'slave_id' in reg:
                    # For master mode: include slave ID in comment
                    base_tag = reg.get('tag_name', f'REG_{reg["internal_address"]}')
                    if base_tag.startswith(('S1_', 'S2_', 'S3_', 'S4_', 'S5_', 'S6_', 'S7_', 'S8_', 'S9_')):
                        base_tag = base_tag[3:]
                    tag_name = f'S{reg["slave_id"]}_{base_tag}'
                else:
                    tag_name = reg.get('tag_name', f'REG_{reg["internal_address"]}')
                
                operation = 0 if reg.get('operation', 'Read') == 'Read' else 1
                mode = 0 if reg.get('mode', 'One-time') == 'One-time' else 1
                
                # Format with dynamic padding to align commas
                data_str = f"{{{reg['internal_address']}, {idx}, {operation}, {mode}}}"
                padding = max_addr_width + max_idx_width + 12  # Base padding for {}, spaces, commas
                source += f"    {data_str},{'':>{padding - len(data_str)}} /* {tag_name} - {reg.get('operation', 'N/A')}/{reg.get('mode', 'N/A')} */\n"
            source += "};\n\n"
        else:
            source += "const modbus_register_map_enhanced_t g_modbus_discrete_input_map[1] = {{0, 0, 0, 0}};\n\n"
        
        source += f"/* Optimized register ranges ({len(optimized_ranges)} ranges) */\n"
        source += f"const modbus_register_range_t g_modbus_register_ranges[{max(1, len(optimized_ranges))}] = {{\n"
        
        if optimized_ranges:
            # Calculate max width for alignment
            max_start_width = max(len(str(rng['start'])) for rng in optimized_ranges)
            max_count_width = max(len(str(rng['count'])) for rng in optimized_ranges)
            
            for i, rng in enumerate(optimized_ranges):
                data_str = f"{{{rng['start']}, {rng['count']}, {rng['type']}}}"
                padding = max_start_width + max_count_width + 12  # Base padding
                source += f"    {data_str}{',' if i < len(optimized_ranges) - 1 else ' '}{'':>{padding - len(data_str)}} /* {self._get_range_comment(rng)} */\n"
        else:
            source += "    {0, 0, 0}                                   /* No registers defined */\n"
        
        source += "};\n\n"
        
        source += '''/**
 * \\brief           Check if register address is valid for given type
 * \\param[in]       addr: Internal register address (0-based)
 * \\param[in]       reg_type: Register type (0=coil, 1=DI, 3=IR, 4=HR)
 * \\return          `1` if register is valid, `0` otherwise
 */
uint8_t
modbus_is_register_valid(uint16_t addr, uint8_t reg_type) {
    const modbus_register_map_enhanced_t* map;
    int32_t count;
    int32_t left, right, mid;
    
    /* Select appropriate map */
    switch (reg_type) {
        case 0:                                     /* Coil */
            map = g_modbus_coil_map;
            count = MODBUS_COIL_COUNT;
            break;
        case 1:                                     /* Discrete Input */
            map = g_modbus_discrete_input_map;
            count = MODBUS_DISCRETE_INPUT_COUNT;
            break;
        case 3:                                     /* Input Register */
            map = g_modbus_input_register_map;
            count = MODBUS_INPUT_REGISTER_COUNT;
            break;
        case 4:                                     /* Holding Register */
            map = g_modbus_holding_register_map;
            count = MODBUS_HOLDING_REGISTER_COUNT;
            break;
        default:
            return 0;
    }
    
    /* Binary search in sorted map */
    if (count == 0) {
        return 0;
    }
    
    left = 0;
    right = count - 1;
    while (left <= right) {
        mid = (left + right) / 2;
        if (map[mid].internal_addr == addr) {
            return 1;
        } else if (map[mid].internal_addr < addr) {
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }
    
    return 0;
}

/**
 * \\brief           Get pointer to register ranges array
 * \\param[in]       ranges: Pointer to store ranges array pointer
 * \\return          Number of ranges
 */
int32_t
modbus_get_register_ranges(const modbus_register_range_t** ranges) {
    if (ranges != NULL) {
        *ranges = g_modbus_register_ranges;
    }
    return MODBUS_REGISTER_RANGES_COUNT;
}

/**
 * \\brief           Initialize register values to default
 * \\note            User can modify this function to set initial values
 */
void
modbus_registers_init(void) {
    /* Initialize register values if needed */
    /* User implementation goes here */
}

/* Enhanced functions for Master mode */
#if defined(MODBUS_DEVICE_TYPE_MASTER)

/**
 * \\brief           Check if register is configured for Read operation
 * \\param[in]       addr: Internal register address (0-based)
 * \\param[in]       reg_type: Register type (0=coil, 1=DI, 3=IR, 4=HR)
 * \\return          `1` if register is Read type, `0` otherwise
 */
uint8_t
modbus_is_read_register(uint16_t addr, uint8_t reg_type) {
    const modbus_register_map_enhanced_t* map;
    int32_t count;
    int32_t left, right, mid;
    
    /* Select appropriate map */
    switch (reg_type) {
        case 0:
            map = g_modbus_coil_map;
            count = MODBUS_COIL_COUNT;
            break;
        case 1:
            map = g_modbus_discrete_input_map;
            count = MODBUS_DISCRETE_INPUT_COUNT;
            break;
        case 3:
            map = g_modbus_input_register_map;
            count = MODBUS_INPUT_REGISTER_COUNT;
            break;
        case 4:
            map = g_modbus_holding_register_map;
            count = MODBUS_HOLDING_REGISTER_COUNT;
            break;
        default:
            return 0;
    }
    
    /* Binary search in sorted map */
    if (count == 0) {
        return 0;
    }
    
    left = 0;
    right = count - 1;
    while (left <= right) {
        mid = (left + right) / 2;
        if (map[mid].internal_addr == addr) {
            return (map[mid].operation == 0) ? 1 : 0;  /* 0 = Read */
        } else if (map[mid].internal_addr < addr) {
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }
    
    return 0;
}

/**
 * \\brief           Check if register is configured for Write operation
 * \\param[in]       addr: Internal register address (0-based)
 * \\param[in]       reg_type: Register type (0=coil, 1=DI, 3=IR, 4=HR)
 * \\return          `1` if register is Write type, `0` otherwise
 */
uint8_t
modbus_is_write_register(uint16_t addr, uint8_t reg_type) {
    const modbus_register_map_enhanced_t* map;
    int32_t count;
    int32_t left, right, mid;
    
    /* Select appropriate map */
    switch (reg_type) {
        case 0:
            map = g_modbus_coil_map;
            count = MODBUS_COIL_COUNT;
            break;
        case 1:
            map = g_modbus_discrete_input_map;
            count = MODBUS_DISCRETE_INPUT_COUNT;
            break;
        case 3:
            map = g_modbus_input_register_map;
            count = MODBUS_INPUT_REGISTER_COUNT;
            break;
        case 4:
            map = g_modbus_holding_register_map;
            count = MODBUS_HOLDING_REGISTER_COUNT;
            break;
        default:
            return 0;
    }
    
    /* Binary search in sorted map */
    if (count == 0) {
        return 0;
    }
    
    left = 0;
    right = count - 1;
    while (left <= right) {
        mid = (left + right) / 2;
        if (map[mid].internal_addr == addr) {
            return (map[mid].operation == 1) ? 1 : 0;  /* 1 = Write */
        } else if (map[mid].internal_addr < addr) {
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }
    
    return 0;
}

/**
 * \\brief           Check if register is configured for Cyclic Write operation
 * \\param[in]       addr: Internal register address (0-based)
 * \\param[in]       reg_type: Register type (0=coil, 1=DI, 3=IR, 4=HR)
 * \\return          `1` if register is Cyclic Write type, `0` otherwise
 */
uint8_t
modbus_is_cyclic_write_register(uint16_t addr, uint8_t reg_type) {
    const modbus_register_map_enhanced_t* map;
    int32_t count;
    int32_t left, right, mid;
    
    /* Select appropriate map */
    switch (reg_type) {
        case 0:
            map = g_modbus_coil_map;
            count = MODBUS_COIL_COUNT;
            break;
        case 1:
            map = g_modbus_discrete_input_map;
            count = MODBUS_DISCRETE_INPUT_COUNT;
            break;
        case 3:
            map = g_modbus_input_register_map;
            count = MODBUS_INPUT_REGISTER_COUNT;
            break;
        case 4:
            map = g_modbus_holding_register_map;
            count = MODBUS_HOLDING_REGISTER_COUNT;
            break;
        default:
            return 0;
    }
    
    /* Binary search in sorted map */
    if (count == 0) {
        return 0;
    }
    
    left = 0;
    right = count - 1;
    while (left <= right) {
        mid = (left + right) / 2;
        if (map[mid].internal_addr == addr) {
            return (map[mid].operation == 1 && map[mid].mode == 1) ? 1 : 0;  /* Write + Cyclic */
        } else if (map[mid].internal_addr < addr) {
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }
    
    return 0;
}

/**
 * \\brief           Get total count of Read registers
 * \\return          Number of Read registers
 */
int32_t
modbus_get_read_registers_count(void) {
    int32_t count = 0;
    int32_t i;
    
    /* Count Read registers in all types */
    for (i = 0; i < MODBUS_HOLDING_REGISTER_COUNT; ++i) {
        if (g_modbus_holding_register_map[i].operation == 0) {
            count++;
        }
    }
    for (i = 0; i < MODBUS_INPUT_REGISTER_COUNT; ++i) {
        if (g_modbus_input_register_map[i].operation == 0) {
            count++;
        }
    }
    for (i = 0; i < MODBUS_COIL_COUNT; ++i) {
        if (g_modbus_coil_map[i].operation == 0) {
            count++;
        }
    }
    for (i = 0; i < MODBUS_DISCRETE_INPUT_COUNT; ++i) {
        if (g_modbus_discrete_input_map[i].operation == 0) {
            count++;
        }
    }
    
    return count;
}

/**
 * \\brief           Get total count of Write registers
 * \\return          Number of Write registers
 */
int32_t
modbus_get_write_registers_count(void) {
    int32_t count = 0;
    int32_t i;
    
    /* Count Write registers in all types */
    for (i = 0; i < MODBUS_HOLDING_REGISTER_COUNT; ++i) {
        if (g_modbus_holding_register_map[i].operation == 1) {
            count++;
        }
    }
    for (i = 0; i < MODBUS_INPUT_REGISTER_COUNT; ++i) {
        if (g_modbus_input_register_map[i].operation == 1) {
            count++;
        }
    }
    for (i = 0; i < MODBUS_COIL_COUNT; ++i) {
        if (g_modbus_coil_map[i].operation == 1) {
            count++;
        }
    }
    for (i = 0; i < MODBUS_DISCRETE_INPUT_COUNT; ++i) {
        if (g_modbus_discrete_input_map[i].operation == 1) {
            count++;
        }
    }
    
    return count;
}

#endif /* MODBUS_DEVICE_TYPE_MASTER */
'''
        
        return source
    
    def _get_range_comment(self, rng):
        """Get comment for register range"""
        type_names = {
            0: 'Coils',
            1: 'DI',
            3: 'Input Regs',
            4: 'Holding Regs'
        }
        
        type_name = type_names.get(rng['type'], f'Type{rng["type"]}')
        
        if rng['count'] == 1:
            return f"{type_name} {rng['start']}"
        else:
            end_addr = rng['start'] + rng['count'] - 1
            return f"{type_name} {rng['start']}-{end_addr}"
    
    def parse_header(self, filename):
        """Parse enhanced .h file and return config"""
        with open(filename, 'r', encoding='utf-8') as f:
            content = f.read()
        
        config = {
            'slave_id': 1,
            'is_master': False,
            'target_slaves': [],
            'slave_registers': {},
            'registers': [],
            'settings': self._get_default_settings()
        }
        
        if '#define MODBUS_DEVICE_TYPE_MASTER' in content:
            config['is_master'] = True
            
            target_match = re.search(r'/\* Target slave IDs: ([0-9, ]+) \*/', content)
            if target_match:
                slave_ids = [int(x.strip()) for x in target_match.group(1).split(',')]
                config['target_slaves'] = slave_ids
                for slave_id in slave_ids:
                    config['slave_registers'][slave_id] = []
        
        # Enhanced pattern to capture operation and mode info
        tag_pattern = r'#define\s+([A-Z0-9_]+)_ADDR\s+\((\d+)\)\s+/\*\s*(?:Slave\s+(\d+),\s*)?.*?(?:Op:\s*(\w+),\s*Mode:\s*(\w+))?'
        matches = re.findall(tag_pattern, content)
        
        for match in matches:
            tag_name = match[0]
            internal_addr = int(match[1])
            slave_id_str = match[2]
            operation = match[3] if match[3] else 'Read'
            mode = match[4] if match[4] else 'N/A'
            
            if 'COIL' in tag_name and 'DISCRETE' not in tag_name:
                modbus_type = 0
                combo_index = 0
                mapped_addr = internal_addr + 1
            elif 'DI' in tag_name or 'DISCRETE' in tag_name:
                modbus_type = 1
                combo_index = 1
                mapped_addr = 10000 + internal_addr + 1
            elif 'INPUT_REG' in tag_name or 'IR' in tag_name:
                modbus_type = 3
                combo_index = 2
                mapped_addr = 30000 + internal_addr + 1
            elif 'HOLDING_REG' in tag_name or 'HR' in tag_name:
                modbus_type = 4
                combo_index = 3
                mapped_addr = 40000 + internal_addr + 1
            else:
                continue
            
            register = {
                'tag_name': tag_name,
                'internal_address': internal_addr,
                'mapped_address': mapped_addr,
                'type': combo_index,
                'modbus_type': modbus_type,
                'type_name': ['Coil (0x)', 'Discrete Input (1x)', 'Input Register (3x)', 'Holding Register (4x)'][combo_index],
                'operation': operation,
                'mode': mode
            }
            
            if config['is_master'] and slave_id_str:
                slave_id = int(slave_id_str)
                if slave_id not in config['target_slaves']:
                    config['target_slaves'].append(slave_id)
                if slave_id not in config['slave_registers']:
                    config['slave_registers'][slave_id] = []
                config['slave_registers'][slave_id].append(register)
            else:
                config['registers'].append(register)
        
        return config
    
    def _get_default_settings(self):
        """Get default enhanced settings"""
        return {
            'common': [
                {'var_name': 'MODBUS_BAUDRATE', 'value': '9600', 'description': 'UART baudrate'},
                {'var_name': 'MODBUS_DATA_BITS', 'value': '8', 'description': 'Data bits: 7 or 8'},
                {'var_name': 'MODBUS_PARITY', 'value': '0', 'description': 'Parity: 0=None, 1=Even, 2=Odd'},
                {'var_name': 'MODBUS_STOP_BITS', 'value': '1', 'description': 'Stop bits: 1 or 2'},
            ],
            'master': [
                {'var_name': 'MODBUS_TIMEOUT_MS', 'value': '1000', 'description': 'Response timeout (ms)'},
                {'var_name': 'MODBUS_FRAME_INTERVAL_MS', 'value': '10', 'description': 'Time between frames in one cycle (ms)'},
                {'var_name': 'MODBUS_CYCLE_INTERVAL_MS', 'value': '100', 'description': 'Time between complete cycles (ms)'},
                {'var_name': 'MODBUS_MAX_RETRIES', 'value': '3', 'description': 'Maximum retry attempts'},
            ],
            'slave': [
                {'var_name': 'MODBUS_SLAVE_ID', 'value': '1', 'description': 'Modbus slave address (1-247)'},
                {'var_name': 'MODBUS_RESPONSE_DELAY_MS', 'value': '0', 'description': 'Response delay (ms)'},
            ]
        }