/**
 * \file            modbus_registers.c
 * \brief           Modbus register mapping implementation
 */

/*
 * Copyright (c) 2025 Pham Nam Hien
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without restriction,
 * including without limitation the rights to use, copy, modify, merge,
 * publish, distribute, sublicense, and/or sell copies of the Software,
 * and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE
 * AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 *
 * This file is part of Modbus RTU library.
 *
 * Author:          Generated by Modbus Configuration Tool
 */
#include "modbus_registers.h"

/* Configuration variables - can be modified at runtime */

/* Common configuration variables */
uint32_t modbus_baudrate = 9600;
uint32_t modbus_data_bits = 8;
uint32_t modbus_parity = 0;
uint32_t modbus_stop_bits = 1;

/* Slave-specific configuration variables */
uint32_t modbus_slave_id = 1;
uint32_t modbus_response_delay_ms = 0;

/* Data arrays - only allocate what we actually use */
uint16_t g_modbus_holding_registers[3];
uint16_t g_modbus_input_registers[4];
uint8_t  g_modbus_coils[1];
uint8_t  g_modbus_discrete_inputs[1];

/* Address to array index mapping */
const modbus_register_map_t g_modbus_holding_register_map[3] = {
    {    0,   0},                  /* HR_0000 */
    {    1,   1},                  /* HR_0001 */
    {    2,   2},                  /* HR_0002 */
};

const modbus_register_map_t g_modbus_input_register_map[4] = {
    {    0,   0},                  /* IR_0000 */
    {    3,   1},                  /* IR_0003 */
    {    4,   2},                  /* IR_0004 */
    {  100,   3},                  /* IR_0100 */
};

const modbus_register_map_t g_modbus_coil_map[7] = {
    {    0,   0},                  /* COIL_0000 */
    {    1,   1},                  /* COIL_0001 */
    {    2,   2},                  /* COIL_0002 */
    {    3,   3},                  /* COIL_0003 */
    {    4,   4},                  /* COIL_0004 */
    {    5,   5},                  /* COIL_0005 */
    {    6,   6},                  /* COIL_0006 */
};

const modbus_register_map_t g_modbus_discrete_input_map[3] = {
    {    0,   0},                  /* DI_0000 */
    {    1,   1},                  /* DI_0001 */
    {    2,   2},                  /* DI_0002 */
};

/* Optimized register ranges (6 ranges) */
const modbus_register_range_t g_modbus_register_ranges[6] = {
    {    0,   3, 4},                      /* Holding Regs 0-2 */
    {    0,   1, 3},                      /* Input Regs 0 */
    {    3,   2, 3},                      /* Input Regs 3-4 */
    {  100,   1, 3},                      /* Input Regs 100 */
    {    0,   3, 1},                      /* DI 0-2 */
    {    0,   7, 0}                      /* Coils 0-6 */
};

/**
 * \brief           Check if register address is valid for given type
 * \param[in]       addr: Internal register address (0-based)
 * \param[in]       reg_type: Register type (0=coil, 1=DI, 3=IR, 4=HR)
 * \return          `1` if register is valid, `0` otherwise
 */
uint8_t
modbus_is_register_valid(uint16_t addr, uint8_t reg_type) {
    const modbus_register_map_t* map;
    int32_t count;
    int32_t left, right, mid;
    
    /* Select appropriate map */
    switch (reg_type) {
        case 0:                                     /* Coil */
            map = g_modbus_coil_map;
            count = MODBUS_COIL_COUNT;
            break;
        case 1:                                     /* Discrete Input */
            map = g_modbus_discrete_input_map;
            count = MODBUS_DISCRETE_INPUT_COUNT;
            break;
        case 3:                                     /* Input Register */
            map = g_modbus_input_register_map;
            count = MODBUS_INPUT_REGISTER_COUNT;
            break;
        case 4:                                     /* Holding Register */
            map = g_modbus_holding_register_map;
            count = MODBUS_HOLDING_REGISTER_COUNT;
            break;
        default:
            return 0;
    }
    
    /* Binary search in sorted map */
    if (count == 0) {
        return 0;
    }
    
    left = 0;
    right = count - 1;
    while (left <= right) {
        mid = (left + right) / 2;
        if (map[mid].internal_addr == addr) {
            return 1;
        } else if (map[mid].internal_addr < addr) {
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }
    
    return 0;
}

/**
 * \brief           Get pointer to register ranges array
 * \param[in]       ranges: Pointer to store ranges array pointer
 * \return          Number of ranges
 */
int32_t
modbus_get_register_ranges(const modbus_register_range_t** ranges) {
    if (ranges != NULL) {
        *ranges = g_modbus_register_ranges;
    }
    return MODBUS_REGISTER_RANGES_COUNT;
}

/**
 * \brief           Initialize register values to default
 * \note            User can modify this function to set initial values
 */
void
modbus_registers_init(void) {
    /* Initialize register values if needed */
    /* User implementation goes here */
}
