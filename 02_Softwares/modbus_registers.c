/**
 * \file            modbus_registers.c
 * \brief           Enhanced Modbus register mapping implementation with Operation/Mode support
 */

/*
 * Copyright (c) 2025 Pham Nam Hien
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without restriction,
 * including without limitation the rights to use, copy, modify, merge,
 * publish, distribute, sublicense, and/or sell copies of the Software,
 * and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE
 * AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 *
 * This file is part of Enhanced Modbus RTU library v2.0.
 *
 * Author:          Generated by Enhanced Modbus Configuration Tool v2.0
 */
#include "modbus_registers.h"

/* Configuration variables - can be modified at runtime */

/* Common configuration variables */
uint32_t modbus_baudrate = 9600;
uint32_t modbus_data_bits = 8;
uint32_t modbus_parity = 0;
uint32_t modbus_stop_bits = 1;

/* Slave-specific configuration variables */
uint32_t modbus_slave_id = 1;
uint32_t modbus_response_delay_ms = 0;

/* Data arrays - only allocate what we actually use */
uint16_t g_modbus_holding_registers[2];
uint16_t g_modbus_input_registers[1];              /* Placeholder */
uint8_t  g_modbus_coils[1];                        /* Placeholder */
uint8_t  g_modbus_discrete_inputs[1];              /* Placeholder */

/* Enhanced address to array index mapping with operation/mode info */
const modbus_register_map_enhanced_t g_modbus_holding_register_map[2] = {
    {0, 0, 1, 1},   /* HR_0000 - N/A/N/A */
    {1, 1, 1, 1},   /* HR_0001 - N/A/N/A */
};

const modbus_register_map_enhanced_t g_modbus_input_register_map[1] = {{0, 0, 0, 0}};

const modbus_register_map_enhanced_t g_modbus_coil_map[1] = {{0, 0, 0, 0}};

const modbus_register_map_enhanced_t g_modbus_discrete_input_map[1] = {{0, 0, 0, 0}};

/* Optimized register ranges (1 ranges) */
const modbus_register_range_t g_modbus_register_ranges[1] = {
    {0, 2, 4}       /* Holding Regs 0-1 */
};

/**
 * \brief           Check if register address is valid for given type
 * \param[in]       addr: Internal register address (0-based)
 * \param[in]       reg_type: Register type (0=coil, 1=DI, 3=IR, 4=HR)
 * \return          `1` if register is valid, `0` otherwise
 */
uint8_t
modbus_is_register_valid(uint16_t addr, uint8_t reg_type) {
    const modbus_register_map_enhanced_t* map;
    int32_t count;
    int32_t left, right, mid;
    
    /* Select appropriate map */
    switch (reg_type) {
        case 0:                                     /* Coil */
            map = g_modbus_coil_map;
            count = MODBUS_COIL_COUNT;
            break;
        case 1:                                     /* Discrete Input */
            map = g_modbus_discrete_input_map;
            count = MODBUS_DISCRETE_INPUT_COUNT;
            break;
        case 3:                                     /* Input Register */
            map = g_modbus_input_register_map;
            count = MODBUS_INPUT_REGISTER_COUNT;
            break;
        case 4:                                     /* Holding Register */
            map = g_modbus_holding_register_map;
            count = MODBUS_HOLDING_REGISTER_COUNT;
            break;
        default:
            return 0;
    }
    
    /* Binary search in sorted map */
    if (count == 0) {
        return 0;
    }
    
    left = 0;
    right = count - 1;
    while (left <= right) {
        mid = (left + right) / 2;
        if (map[mid].internal_addr == addr) {
            return 1;
        } else if (map[mid].internal_addr < addr) {
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }
    
    return 0;
}

/**
 * \brief           Get pointer to register ranges array
 * \param[in]       ranges: Pointer to store ranges array pointer
 * \return          Number of ranges
 */
int32_t
modbus_get_register_ranges(const modbus_register_range_t** ranges) {
    if (ranges != NULL) {
        *ranges = g_modbus_register_ranges;
    }
    return MODBUS_REGISTER_RANGES_COUNT;
}

/**
 * \brief           Initialize register values to default
 * \note            User can modify this function to set initial values
 */
void
modbus_registers_init(void) {
    /* Initialize register values if needed */
    /* User implementation goes here */
}

/* Enhanced functions for Master mode */
#if defined(MODBUS_DEVICE_TYPE_MASTER)

/**
 * \brief           Check if register is configured for Read operation
 * \param[in]       addr: Internal register address (0-based)
 * \param[in]       reg_type: Register type (0=coil, 1=DI, 3=IR, 4=HR)
 * \return          `1` if register is Read type, `0` otherwise
 */
uint8_t
modbus_is_read_register(uint16_t addr, uint8_t reg_type) {
    const modbus_register_map_enhanced_t* map;
    int32_t count;
    int32_t left, right, mid;
    
    /* Select appropriate map */
    switch (reg_type) {
        case 0:
            map = g_modbus_coil_map;
            count = MODBUS_COIL_COUNT;
            break;
        case 1:
            map = g_modbus_discrete_input_map;
            count = MODBUS_DISCRETE_INPUT_COUNT;
            break;
        case 3:
            map = g_modbus_input_register_map;
            count = MODBUS_INPUT_REGISTER_COUNT;
            break;
        case 4:
            map = g_modbus_holding_register_map;
            count = MODBUS_HOLDING_REGISTER_COUNT;
            break;
        default:
            return 0;
    }
    
    /* Binary search in sorted map */
    if (count == 0) {
        return 0;
    }
    
    left = 0;
    right = count - 1;
    while (left <= right) {
        mid = (left + right) / 2;
        if (map[mid].internal_addr == addr) {
            return (map[mid].operation == 0) ? 1 : 0;  /* 0 = Read */
        } else if (map[mid].internal_addr < addr) {
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }
    
    return 0;
}

/**
 * \brief           Check if register is configured for Write operation
 * \param[in]       addr: Internal register address (0-based)
 * \param[in]       reg_type: Register type (0=coil, 1=DI, 3=IR, 4=HR)
 * \return          `1` if register is Write type, `0` otherwise
 */
uint8_t
modbus_is_write_register(uint16_t addr, uint8_t reg_type) {
    const modbus_register_map_enhanced_t* map;
    int32_t count;
    int32_t left, right, mid;
    
    /* Select appropriate map */
    switch (reg_type) {
        case 0:
            map = g_modbus_coil_map;
            count = MODBUS_COIL_COUNT;
            break;
        case 1:
            map = g_modbus_discrete_input_map;
            count = MODBUS_DISCRETE_INPUT_COUNT;
            break;
        case 3:
            map = g_modbus_input_register_map;
            count = MODBUS_INPUT_REGISTER_COUNT;
            break;
        case 4:
            map = g_modbus_holding_register_map;
            count = MODBUS_HOLDING_REGISTER_COUNT;
            break;
        default:
            return 0;
    }
    
    /* Binary search in sorted map */
    if (count == 0) {
        return 0;
    }
    
    left = 0;
    right = count - 1;
    while (left <= right) {
        mid = (left + right) / 2;
        if (map[mid].internal_addr == addr) {
            return (map[mid].operation == 1) ? 1 : 0;  /* 1 = Write */
        } else if (map[mid].internal_addr < addr) {
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }
    
    return 0;
}

/**
 * \brief           Check if register is configured for Cyclic Write operation
 * \param[in]       addr: Internal register address (0-based)
 * \param[in]       reg_type: Register type (0=coil, 1=DI, 3=IR, 4=HR)
 * \return          `1` if register is Cyclic Write type, `0` otherwise
 */
uint8_t
modbus_is_cyclic_write_register(uint16_t addr, uint8_t reg_type) {
    const modbus_register_map_enhanced_t* map;
    int32_t count;
    int32_t left, right, mid;
    
    /* Select appropriate map */
    switch (reg_type) {
        case 0:
            map = g_modbus_coil_map;
            count = MODBUS_COIL_COUNT;
            break;
        case 1:
            map = g_modbus_discrete_input_map;
            count = MODBUS_DISCRETE_INPUT_COUNT;
            break;
        case 3:
            map = g_modbus_input_register_map;
            count = MODBUS_INPUT_REGISTER_COUNT;
            break;
        case 4:
            map = g_modbus_holding_register_map;
            count = MODBUS_HOLDING_REGISTER_COUNT;
            break;
        default:
            return 0;
    }
    
    /* Binary search in sorted map */
    if (count == 0) {
        return 0;
    }
    
    left = 0;
    right = count - 1;
    while (left <= right) {
        mid = (left + right) / 2;
        if (map[mid].internal_addr == addr) {
            return (map[mid].operation == 1 && map[mid].mode == 1) ? 1 : 0;  /* Write + Cyclic */
        } else if (map[mid].internal_addr < addr) {
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }
    
    return 0;
}

/**
 * \brief           Get total count of Read registers
 * \return          Number of Read registers
 */
int32_t
modbus_get_read_registers_count(void) {
    int32_t count = 0;
    int32_t i;
    
    /* Count Read registers in all types */
    for (i = 0; i < MODBUS_HOLDING_REGISTER_COUNT; ++i) {
        if (g_modbus_holding_register_map[i].operation == 0) {
            count++;
        }
    }
    for (i = 0; i < MODBUS_INPUT_REGISTER_COUNT; ++i) {
        if (g_modbus_input_register_map[i].operation == 0) {
            count++;
        }
    }
    for (i = 0; i < MODBUS_COIL_COUNT; ++i) {
        if (g_modbus_coil_map[i].operation == 0) {
            count++;
        }
    }
    for (i = 0; i < MODBUS_DISCRETE_INPUT_COUNT; ++i) {
        if (g_modbus_discrete_input_map[i].operation == 0) {
            count++;
        }
    }
    
    return count;
}

/**
 * \brief           Get total count of Write registers
 * \return          Number of Write registers
 */
int32_t
modbus_get_write_registers_count(void) {
    int32_t count = 0;
    int32_t i;
    
    /* Count Write registers in all types */
    for (i = 0; i < MODBUS_HOLDING_REGISTER_COUNT; ++i) {
        if (g_modbus_holding_register_map[i].operation == 1) {
            count++;
        }
    }
    for (i = 0; i < MODBUS_INPUT_REGISTER_COUNT; ++i) {
        if (g_modbus_input_register_map[i].operation == 1) {
            count++;
        }
    }
    for (i = 0; i < MODBUS_COIL_COUNT; ++i) {
        if (g_modbus_coil_map[i].operation == 1) {
            count++;
        }
    }
    for (i = 0; i < MODBUS_DISCRETE_INPUT_COUNT; ++i) {
        if (g_modbus_discrete_input_map[i].operation == 1) {
            count++;
        }
    }
    
    return count;
}

#endif /* MODBUS_DEVICE_TYPE_MASTER */
