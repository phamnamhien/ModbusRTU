/**
 * \file            modbus_registers.c
 * \brief           Modbus register mapping implementation
 */

/*
 * Copyright (c) 2025 Pham Nam Hien
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without restriction,
 * including without limitation the rights to use, copy, modify, merge,
 * publish, distribute, sublicense, and/or sell copies of the Software,
 * and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE
 * AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 *
 * This file is part of Modbus RTU library.
 *
 * Author:          Generated by Modbus Configuration Tool
 */
#include "modbus_registers.h"

/* Configuration variables - can be modified at runtime */

/* Common configuration variables */
uint32_t modbus_baudrate = 9600;
uint32_t modbus_data_bits = 8;
uint32_t modbus_parity = 0;
uint32_t modbus_stop_bits = 1;

/* Master-specific configuration variables */
uint32_t modbus_timeout_ms = 1000;
uint32_t modbus_poll_interval_ms = 100;
uint32_t modbus_max_retries = 3;

/* Data arrays - only allocate what we actually use */
uint16_t g_modbus_holding_registers[32];
uint16_t g_modbus_input_registers[1];              /* Placeholder */
uint8_t  g_modbus_coils[1];                        /* Placeholder */
uint8_t  g_modbus_discrete_inputs[1];              /* Placeholder */

/* Address to array index mapping */
const modbus_register_map_t g_modbus_holding_register_map[32] = {
    {    0,   0},                  /* S1_HR_0000 */
    {    1,   1},                  /* S1_HR_0001 */
    {    2,   2},                  /* S2_HR_0002 */
    {    3,   3},                  /* S2_HR_0003 */
    {    4,   4},                  /* S3_HR_0004 */
    {    5,   5},                  /* S3_HR_0005 */
    {    6,   6},                  /* S4_HR_0006 */
    {    7,   7},                  /* S4_HR_0007 */
    {    8,   8},                  /* S5_HR_0008 */
    {    9,   9},                  /* S5_HR_0009 */
    {   10,  10},                  /* S6_HR_0010 */
    {   11,  11},                  /* S6_HR_0011 */
    {   12,  12},                  /* S7_HR_0012 */
    {   13,  13},                  /* S7_HR_0013 */
    {   14,  14},                  /* S8_HR_0014 */
    {   15,  15},                  /* S8_HR_0015 */
    {   16,  16},                  /* S9_HR_0016 */
    {   17,  17},                  /* S9_HR_0017 */
    {   18,  18},                  /* S10_HR_0018 */
    {   19,  19},                  /* S10_HR_0019 */
    {   20,  20},                  /* S11_HR_0020 */
    {   21,  21},                  /* S11_HR_0021 */
    {   22,  22},                  /* S12_HR_0022 */
    {   23,  23},                  /* S12_HR_0023 */
    {   24,  24},                  /* S13_HR_0024 */
    {   25,  25},                  /* S13_HR_0025 */
    {   26,  26},                  /* S14_HR_0026 */
    {   27,  27},                  /* S14_HR_0027 */
    {   28,  28},                  /* S16_HR_0028 */
    {   29,  29},                  /* S16_HR_0029 */
    {   30,  30},                  /* S18_HR_0030 */
    {   31,  31},                  /* S18_HR_0031 */
};

const modbus_register_map_t g_modbus_input_register_map[1] = {{0, 0}};

const modbus_register_map_t g_modbus_coil_map[1] = {{0, 0}};

const modbus_register_map_t g_modbus_discrete_input_map[1] = {{0, 0}};

/* Optimized register ranges (1 ranges) */
const modbus_register_range_t g_modbus_register_ranges[1] = {
    {    0,  32, 4}                      /* Holding Regs 0-31 */
};

/**
 * \brief           Check if register address is valid for given type
 * \param[in]       addr: Internal register address (0-based)
 * \param[in]       reg_type: Register type (0=coil, 1=DI, 3=IR, 4=HR)
 * \return          `1` if register is valid, `0` otherwise
 */
uint8_t
modbus_is_register_valid(uint16_t addr, uint8_t reg_type) {
    const modbus_register_map_t* map;
    int32_t count;
    int32_t left, right, mid;
    
    /* Select appropriate map */
    switch (reg_type) {
        case 0:                                     /* Coil */
            map = g_modbus_coil_map;
            count = MODBUS_COIL_COUNT;
            break;
        case 1:                                     /* Discrete Input */
            map = g_modbus_discrete_input_map;
            count = MODBUS_DISCRETE_INPUT_COUNT;
            break;
        case 3:                                     /* Input Register */
            map = g_modbus_input_register_map;
            count = MODBUS_INPUT_REGISTER_COUNT;
            break;
        case 4:                                     /* Holding Register */
            map = g_modbus_holding_register_map;
            count = MODBUS_HOLDING_REGISTER_COUNT;
            break;
        default:
            return 0;
    }
    
    /* Binary search in sorted map */
    if (count == 0) {
        return 0;
    }
    
    left = 0;
    right = count - 1;
    while (left <= right) {
        mid = (left + right) / 2;
        if (map[mid].internal_addr == addr) {
            return 1;
        } else if (map[mid].internal_addr < addr) {
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }
    
    return 0;
}

/**
 * \brief           Get pointer to register ranges array
 * \param[in]       ranges: Pointer to store ranges array pointer
 * \return          Number of ranges
 */
int32_t
modbus_get_register_ranges(const modbus_register_range_t** ranges) {
    if (ranges != NULL) {
        *ranges = g_modbus_register_ranges;
    }
    return MODBUS_REGISTER_RANGES_COUNT;
}

/**
 * \brief           Initialize register values to default
 * \note            User can modify this function to set initial values
 */
void
modbus_registers_init(void) {
    /* Initialize register values if needed */
    /* User implementation goes here */
}
