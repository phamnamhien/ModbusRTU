#include "modbus_registers.h"
#include <stddef.h>

/**
 * @file    modbus_registers.c  
 * @brief   Modbus register mapping implementation
 * @note    Generated by Modbus Configuration Tool
 */

/* Data arrays - Only allocate what we actually use */
uint16_t g_modbus_holding_registers[5] = {0};
uint16_t g_modbus_input_registers[3] = {0};
uint8_t  g_modbus_coils[1] = {0};  /* Placeholder */
uint8_t  g_modbus_discrete_inputs[1] = {0};  /* Placeholder */

/* Address to array index mapping */
const modbus_register_map_t g_modbus_holding_register_map[5] = {
    {   0,   0},  /* HR 0 -> array[0] */
    {   1,   1},  /* HR 1 -> array[1] */
    { 100,   2},  /* HR 100 -> array[2] */
    { 101,   3},  /* HR 101 -> array[3] */
    { 102,   4},  /* HR 102 -> array[4] */
};

const modbus_register_map_t g_modbus_input_register_map[3] = {
    {   3,   0},  /* IR 3 -> array[0] */
    {   4,   1},  /* IR 4 -> array[1] */
    {   6,   2},  /* IR 6 -> array[2] */
};

const modbus_register_map_t g_modbus_coil_map[1] = {{0, 0}};

const modbus_register_map_t g_modbus_discrete_input_map[1] = {{0, 0}};

/* Optimized register ranges (4 ranges) */
const modbus_register_range_t g_modbus_register_ranges[4] = {
    {   0,  2, 4},  /* Holding Regs 0-1 */
    { 100,  3, 4},  /* Holding Regs 100-102 */
    {   3,  2, 3},  /* Input Regs 3-4 */
    {   6,  1, 3}  /* Input Regs 6 */
};

/**
 * @brief   Check if register address is valid for given type
 * @param   addr: Internal register address (0-based)
 * @param   reg_type: Register type (0=coil, 1=DI, 3=IR, 4=HR)
 * @return  true if register is valid, false otherwise
 */
bool
modbus_is_register_valid(uint16_t addr, uint8_t reg_type) {
    const modbus_register_map_t *map;
    int count;
    
    /* Select appropriate map */
    switch(reg_type) {
        case 0:  /* Coil */
            map = g_modbus_coil_map;
            count = MODBUS_COIL_COUNT;
            break;
        case 1:  /* Discrete Input */
            map = g_modbus_discrete_input_map;
            count = MODBUS_DISCRETE_INPUT_COUNT;
            break;
        case 3:  /* Input Register */
            map = g_modbus_input_register_map;
            count = MODBUS_INPUT_REGISTER_COUNT;
            break;
        case 4:  /* Holding Register */
            map = g_modbus_holding_register_map;
            count = MODBUS_HOLDING_REGISTER_COUNT;
            break;
        default:
            return false;
    }
    
    /* Binary search in sorted map */
    if (count == 0) return false;
    
    int left = 0, right = count - 1;
    while (left <= right) {
        int mid = (left + right) / 2;
        if (map[mid].internal_addr == addr) {
            return true;
        } else if (map[mid].internal_addr < addr) {
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }
    
    return false;
}

/**
 * @brief   Get pointer to register ranges array
 * @param   ranges: Pointer to store ranges array pointer
 * @return  Number of ranges
 */
int
modbus_get_register_ranges(const modbus_register_range_t **ranges) {
    if (ranges != NULL) {
        *ranges = g_modbus_register_ranges;
    }
    return MODBUS_REGISTER_RANGES_COUNT;
}

/**
 * @brief   Initialize register values to default
 * @note    User can modify this function to set initial values
 */
void
modbus_registers_init(void) {
    /* Initialize register values if needed */
    /* User implementation goes here */
}
